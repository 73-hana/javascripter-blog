---
title: '変数と定数、データ型'
---

## 変数と定数、データ型

JSで何かしらのデータを扱う場合、ほとんどの場合はそのデータを保管しておく箱とデータそのものをプログラム内で作る方法が必要になります。

このページでは、データを格納する箱として変数と定数（加えてその箱に名前をつけるときに使う識別子）、そしてデータの生成方法について説明します。

### 変数と定数

#### まず初めに、名前について

他のプログラミング言語と同様に、JSでもデータを保持したり使用したりするために名前をつけることができます。データに名前をつけるには**識別子**という文字列を使います。

識別子はデータに名前をつけるために使用される文字列のため、JSがデータと識別子をしっかりと区別できるようにいくつかの規則が定められています。

- 識別子の1文字目はUnicodeの文字、ドル記号、アンダースコアである必要がある（数字は利用できない）

- 識別子の2文字目以降は上記に加えて数字が利用できる

- 予約語は識別子として使えない

JSにおいて、識別子は名前です。なので、変数や定数以外にも、関数名、オブジェクトのプロパティ名、クラス名などに利用されています。データに名前をつける際は識別子のルールを確認してみてください。

#### 変数と定数

変数とは、値を記憶する領域に名前（識別子）をつけたものです。変数は、その名前の通り内容を書き換えることができます。

JSで変数を利用したい場合は、変数を宣言する必要があります。変数にデータを格納したいときは、データの割り当てを行います。

```js
let variableData; // 変数の宣言（letと識別子を使う）
variableData = 'sample'; // データの割り当て（特に最初の割り当てを初期化という）

let variableValue = 12345; // 変数の宣言と初期化はまとめてできる
```

宣言された変数は初期化されない限り`undefined`になります。

定数は、変数と同じくデータを記憶する入れ物のようなものですが、いくつか異なる点があります。

定数は初期値を書き換えることができません。また、定数の宣言時に初期化する必要があります。

```js
const tax = 1.08; // 定数の宣言と初期化
```

#### 変数と定数、どっちを使う？

変数と定数の使い分けについては諸説ありますが、おそらく支配的であろう考え方は「定数を優先的に使用する」ことです。

理由としては、コードを書いていく上で再代入したいという状況があまりないからです。データを加工して再代入する場合は、再代入ではなく別の名前を付けた方がコードが読みやすいからです。

よって、値に名前をつける場合はひとまず`const`を用いておき、再代入する必要がある場合にのみ`let`に書き換えるやり方が推奨されています。

※あくまでも考え方の一つです。

### データ型

#### ２種類のデータ型について

JSにおいて、値は2種類に分けられます。プリミティブ（基本）型とオブジェクト型です。

プリミティブ型に分類されるデータ型は6種類あります。

1. 数値
2. 文字列
3. 論理値
4. null
5. undefined
6. シンボル

そして、上記6つ以外のデータ型がオブジェクト型です。

プリミティブ型の1番の特徴は、不変であることです。プリミティブ型の値を一度でも作ると、その後は変更できません。対して、オブジェクト型は可変なので、内容をいつでも変更することができます。言い換えると、プリミティブ型を代入した変数は別の値を再代入することでしか内容を書き換えられないのに対し、オブジェクト型を代入した変数はいつでも内容を変更することができます。加えて、プリミティブ型を持つ定数は内容を変更できないのに対し、オブジェクト型を持つ定数は内容を変更することができます（しかし別のオブジェクトを再代入することはできません）。

JSのデータを扱う際、特にプリミティブ型に対してメソッドを使用する際に、上記情報は有益です。

#### データを生成する2つの方法

JSのプログラムの中でデータを格納する箱として変数と定数、そしてその箱に名前をつける方法として識別子というものがありました。ここからは、データそのものを生成する方法について説明します。

JSでは、データそのものを生成する方法が2つあります。1つ目はリテラル、もう一つはコンストラクタ関数です。

リテラルとは、値を直接生成するための方法であり、JSのコード上で最もよく見るデータ生成方法です。

#### 数値

数値型は、JSのプログラム内で実数を扱うときに使用するデータ型です。実数といっても、全ての実数をズレもなく扱えるわけではありません。

JSは64ビットの浮動小数点方式で数値を表します。そのため、精度を保証できる範囲が限られてしまいます。一部の実数、例えば循環小数や無理数などはその制約のためにうまく扱うことができません。

```js
console.log(0.1 + 0.2); // 0.1を2進数で表そうとすると循環小数になってしまうため、丸め誤差が発生してしまう
```

よって、正確な計算が求められる場合は、上記の浮動小数点方式のクセを気に留めておく必要があります。

JSで数値型を扱うには、数値リテラルと`Number()`コンストラクタのいずれかを利用します。コンストラクタは数値の変換などに使われますが、一般的には数値リテラルを使用します。

数値リテラルには整数リテラルと浮動小数点リテラルがあります。整数リテラルは2進数、8進数、10進数、16進数を表すことができます。

```js
let int10 = 10; // 整数リテラルの10進数
let int2 = 0b10; // -> 2 整数リテラルの2進数（0Bでも可）
let int8 = 0o17; // -> 9 整数リテラルの8進数（0Oでも可）
let int16 = 0xff; // -> 255 整数リテラルの16進数（0Xでも可）
```

浮動小数点リテラルは、一般的な小数点数と指数表記を用いることができます。

```js
let decimal = 0.1234; // 小数
let scientificNotation = 2.3e-11 // -> 0.000000000023 小数の指数表記
```

#### 文字列

文字列型は、16ビットの値が順序よく並んだデータの型です。16ビットの値がそれぞれUnicodeの1文字を表しています。

JSで文字列型を扱うには、数値型と同じように文字列リテラルと`String()`コンストラクタのいずれかを使用します。しかし、コンストラクタはほとんど使われません。

文字列リテラルは、単一引用符（シングルクォート）か二重引用符（ダブルクォート）で文字または文章を囲みます。どちらで記述しても結果に違いはありません。用途や個人の好みで使い分けられています。

ちなみに、ブラウザで扱うJSにはHTML文字列が埋め込まれていたり、HTMLファイルの中に直接JSコードを記述したりする機会がしばしばあります。HTMLの属性値を記述するときにも引用符を使うので、HTMLとJSで使う引用符を分ける方がより安全な運用が実現できます。

```js
let strSingle = 'sample text';
let strDouble = "sample text";
```

また、ES6以降はバッククォートでも文字列を囲めるようになりました。バッククォートを用いた場合はリテラル内に変数（と1つの値に定まる式）を埋め込む（補間する）ことができます。

バッククォートで文字列を囲むリテラルは単一引用符および二重引用符で文字列を囲む文字列リテラルと性質が異なるため、テンプレートリテラルと別名がついています。

```js
let variable = 'another text';
let tempLiteral = `sapmle text, ${variable}`;
```

文字列内に改行を含めたい場合、単一引用符および二重引用符では「\n」を記述します。バッククォートで囲むテンプレートリテラルの場合は改行がそのまま出力されます。

```js
let singleOrDouble = "sample\ntext"; 
// -> sample
// text
let tempLiteral = `sample
text`;
// -> sample
// text
```

#### 論理値

論理値とは「そうである」か「そうでない」かといったものを表すための値です。JSでは`true`と`false`が予約語に指定されており、これらで論理値を表します。

JSの値は全て論理値に変換できます。`false`に変換できる値は以下の6つです。

```js
let bool1 = Boolean(undefined); // -> false
let bool2 = Boolean(null); // -> false
let bool3 = Boolean(0); // -> false
let bool4 = Boolean(-0); // -> false
let bool5 = Boolean(NaN); // -> false
let bool6 = Boolean(''); // -> false
```

上記以外は全て`true`に変換されます。

論理値を生成するには、論理値リテラル（`true`と`false`の2つのみ）を使うか、`Boolean()`コンストラクタを使用します。

コンストラクタを使用するとコードが冗長になります。加えて以下のようなミスが起きる可能性があります。よってコンストラクタの使用は推奨されていません。

```js
const bool1 = Boolean(false); // -> Boolean false
const bool2 = false; // -> Boolean false
const bool3 = Boolean('false'); // -> Boolean true (空文字列以外の文字列はすべてtrueに変換される)
const bool4 = new Boolean(false); // -> object -> true (オブジェクトはtrueに変換される)
```

論理値はフラグとして単体で利用することも、式と演算子の評価値として利用されることもあります。

```js
let flag = false;
if (flag) {
  console.log('turned on');
}

let password = '';
if (password === 'samplepass') {
  console.log('hello John!');
} else {
  console.log('invalid password...');
}
```

#### nullとundefined

JSの特殊な値としてnullとundefinedの2つが用意されています。これは「存在していないもの」を示す値です。同じような状態を示している2つですが、意味合いが異なります。

```js
console.log(typeof null); // -> object
```

`typeof`演算子を用いると、`null`は`object`であると出力されます。`null`は「オブジェクトが存在していない」という意味の特別なオブジェクト値であると見なされています。実際はオブジェクトに対してだけでなくプリミティブに対しても「値がない」ということを示すために利用されています。

また、`null`は予約語です。

```js
console.log(typeof undefined); // -> undefined
```

`typeof`演算子を用いると、`undefined`は`undefined`であると出力されます。`undefined`は「値が未定義である」という状態を示しており、初期化されていない変数の値や存在していないオブジェクトのプロパティや配列の要素の値に利用されています。

`undefined`は予約語ではなく、あらかじめ定義されたグローバル定数です。

よって、両者の比較すると、`null`は値を持った値（その値は「何もない」という意味を持っている）で、`undefined`は値がない状態です。

トイレットペーパーで例えると、トイレットペーパーが切れている状態は`0`、トイレットペーパーの芯すらない（値がない）状態は`null`、トイレットペーパーを設置する場所すらない（その場所が何のためのものなのか定義されていない）状態は`undefined`となります。

よって、プログラマが意図的に「ここには値がない」ということを示したいとき、値がない状態が恣意的である場合は`null`を使うことが推奨されています。対して、プログラマが「まだ値が設定されていない状態（および関連する動作）を意図的に再現したいとき」に`undefined`を用います。

#### シンボル

シンボルはES6から導入された値の一つで、文字列に変わるプロパティ名として使用されています。

オブジェクトのプロパティ名には通常文字列を用います。（文字列のままプロパティにアクセスするにはプロパティアクセス式のブラケット構文を使います。ドット構文は文字列を識別子に暗黙的に変換するため、識別子に変換できない（不正な文字が含まれる）文字列をプロパティ名にもつオブジェクトにはアクセスできません。）

しかし、一般的な名前を持つプロパティ（例えばnameなど）は誰でも作りたいし使いたいはずなので、もしすでにnameというプロパティが存在しているのに値を代入してしまうと値が上書きされてしまいます。

シンボルを用いるとそれを防ぐことができます。なぜなら、作成されたシンボルはユニークなので、他のシンボルと同じであると評価されることはないからです。

```js
const symb1 = Symbol();
const symb2 = Symbol('symbol');
const symb3 = Symbol('symbol');

console.log(symb1 === symb2); // -> false
console.log(symb2 === symb3); // -> false

const obj1 = {};
const name = Symbol('name');
obj[name] = 'John';
```

上記の例のように、シンボルを作成するにはSymbol()コンストラクタ関数を用います。リテラル表現はありません。コンストラクタ関数には、説明のための文字列を渡すことができます。この説明文は`toString()`メソッドを用いて出力することができます。

オブジェクトのプロパティ名の他にも、たの識別子や値と混同させたくないケースにおいてシンボルは有効です。例えば、ダミー値やフラフを用いる場合、全く関係ない定数同士を比較したときにtrueになる危険性があります。

```js
const MONDAY = 1;
const TUSEDAY = 2;
// ...

const SPRING = 1;
const SUMMER = 2;
// ...

let today = 1;
if (today === MONDAY) {
  // 実行される
}
if (today === SPRING) {
  // 実行される
}
if (MONDAY === SPRING) {
  // 実行される
}
```

ダミー値やフラグの代わりにシンボルを用いることで上記リスクをなくすことができます。

#### オブジェクト

オブジェクトはプリミティブのように不変ではなく、複数の値や複雑な値を保持することができる上に、処理が進むに伴って値を変化させることも可能です。つまりオブジェクトは入れ物のようなものであり、時間と共に内容物に変化があっても不思議ではないと捉えられます。

また、オブジェクトは連想配列とも呼ばれます。JSにおいては同じものを指しています。

オブジェクトを生成する場合も、これまでと同様にリテラルとコンストラクタを使用することができます。しかし、コンストラクタは多少クセがあり、かつ冗長になるだけなので、基本的にはリテラルを用います。

```js
const obj1 = Object('sample'); // -> [String: 'sample']
const str1 = new String('sample'); // -> [String: 'sample']
// -> コンストラクタに値を渡すと、その値に対応する型のラッパオブジェクトを生成する

const obj2 = Object(null);
const obj3 = Object(undefined);
const obj4 = Object();
// -> すべて空のオブジェクトを生成する

const BIRTHPLACE = Symbol();
const obj5 = {
  name: 'John',
  'birth': '2000-12-01',
  [BIRTHPLACE]: 'japan',
}
```

オブジェクトに記憶されるものをプロパティまたはメンバー、ときにはキーと呼ばれます。プロパティは名前と値から成り、名前をキーと呼ぶ場合もあります。

プロパティの名前には文字列あるいはシンボルが利用できます。値には任意のデータ型を使うことができます。また、値に関数を持つプロパティをメソッドと呼びます。

オブジェクトの要素の名称は様々ですが、呼び方が変わるだけで意味するところは同じです。

JSでは、プリミティブの一部（数値、文字列、論理値）に対応するオブジェクト（ラッパーオブジェクト）も用意されています。このオブジェクトが存在する理由は、特殊な値（NaNなど）をプロパティとして保有することで利用できるようにすることと、プリミティブをオブジェクトで囲むことであたかもプリミティブがメソッドを持つように振る舞えるよう手助けすることです。

#### 配列

配列はオブジェクトと似ていますが、格納する値にアクセスする方法として文字列の代わりに順序（値同士の順番）を使用します。

配列にもリテラルとコンストラクタがあります。コンストラクタは引数で配列のサイズを受け取ります。しかし、この仕様がバグの混入の原因になる可能性があるため、コンストラクタの使用は推奨されていません。

```js
const arr1 = new Array(5); // -> [ , , , , ]
const arr2 = [ , , , , ]; // -> [ , , , , ]

const arr3 = new Array(3); // -> [ , , ]
const arr4 = [3]; // [3]

const arr5 = new Array(1, 2, 3); // -> [1, 2, 3]
const arr6 = [1, 2, 3]; // -> [1, 2, 3]
```

## 参考文献

David Flanagan著、村上列訳（2021）『JavaScript 第7版』、オライリージャパン

Ethan Brown著,、武舎広幸・武舎るみ訳（2017）『初めてのJavaScript 第3版』、オライリージャパン

山田祥寛（2018）『JavaScript逆引きレシピ 第2版』、翔泳社
